-- Supabase schema for Lovdata Assistant authentication & billing state
--
-- Run these statements in the Supabase SQL editor or via migrations.
-- They assume the default `public` schema and existing `auth.users` table.

-- Drop tables if you need to reset (be careful in production)
-- drop table if exists public.user_subscriptions cascade;
-- drop table if exists public.stripe_webhook_events cascade;

create table if not exists public.user_subscriptions (
  user_id uuid primary key references auth.users (id) on delete cascade,
  stripe_customer_id text unique,
  stripe_subscription_id text unique,
  status text not null,
  price_id text not null,
  current_period_end timestamptz,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create trigger set_timestamp
before update on public.user_subscriptions
for each row
execute procedure public.set_current_timestamp();

create index if not exists idx_user_subscriptions_status
  on public.user_subscriptions (status);

create index if not exists idx_user_subscriptions_price
  on public.user_subscriptions (price_id);

create table if not exists public.stripe_webhook_events (
  id text primary key,
  type text not null,
  raw jsonb not null,
  received_at timestamptz not null default timezone('utc', now())
);

create index if not exists idx_stripe_webhook_type
  on public.stripe_webhook_events (type);

alter table public.user_subscriptions enable row level security;
alter table public.stripe_webhook_events enable row level security;

-- ---------------------------------------------------------------------------
-- Lovdata archive metadata (migration target for local SQLite)
-- ---------------------------------------------------------------------------

create table if not exists public.lovdata_archives (
  filename text primary key,
  processed_at timestamptz not null default timezone('utc', now()),
  document_count integer not null default 0,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create trigger lovdata_archives_set_timestamp
before update on public.lovdata_archives
for each row
execute procedure public.set_current_timestamp();

create table if not exists public.lovdata_documents (
  id bigint generated by default as identity primary key,
  archive_filename text not null references public.lovdata_archives (filename) on delete cascade,
  member text not null,
  title text,
  document_date text,
  content text not null,
  relative_path text not null,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  tsv_content tsvector generated always as (to_tsvector('norwegian', coalesce(content, ''))) stored
);

create trigger lovdata_documents_set_timestamp
before update on public.lovdata_documents
for each row
execute procedure public.set_current_timestamp();

create unique index if not exists idx_lovdata_documents_archive_member
  on public.lovdata_documents (archive_filename, member);

create index if not exists idx_lovdata_documents_tsv
  on public.lovdata_documents using gin (tsv_content);

alter table public.lovdata_archives enable row level security;
alter table public.lovdata_documents enable row level security;

create policy "Service role manages lovdata archives"
on public.lovdata_archives
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

create policy "Service role manages lovdata documents"
on public.lovdata_documents
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

-- Allow authenticated users to read their own subscription status
create policy "Users can read their subscription"
on public.user_subscriptions
for select
using (auth.uid() = user_id);

-- Service role (backend) can manage subscriptions
create policy "Service role can manage subscriptions"
on public.user_subscriptions
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

-- Only service role can read/write webhook event log
create policy "Service role can manage stripe webhook events"
on public.stripe_webhook_events
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

