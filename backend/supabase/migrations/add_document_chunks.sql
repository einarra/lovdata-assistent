-- Migration: Add document chunks table for granular retrieval
-- This migration adds:
-- 1. document_chunks table for storing document chunks
-- 2. Indexes for efficient chunk search
-- 3. Foreign key relationship to lovdata_documents

-- Create document_chunks table
create table if not exists public.document_chunks (
  id bigint generated by default as identity primary key,
  document_id bigint not null references public.lovdata_documents (id) on delete cascade,
  chunk_index integer not null, -- Order of chunk within document (0-based)
  content text not null,
  content_length integer not null, -- Character count for this chunk
  start_char integer not null, -- Starting character position in original document
  end_char integer not null, -- Ending character position in original document
  -- Metadata preserved from parent document
  archive_filename text not null,
  member text not null,
  document_title text, -- Title of the parent document
  document_date text, -- Date of the parent document
  -- Extracted section metadata (if available)
  section_title text, -- Section/paragraph title if extracted
  section_number text, -- Section number if extracted
  -- Full-text search vector
  tsv_content tsvector generated always as (to_tsvector('norwegian', coalesce(content, ''))) stored,
  -- Embedding vector for semantic search
  embedding vector(1536),
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  -- Ensure unique chunks per document
  constraint unique_document_chunk unique (document_id, chunk_index)
);

-- Create trigger for timestamp updates
create trigger document_chunks_set_timestamp
before update on public.document_chunks
for each row
execute procedure public.set_current_timestamp();

-- Indexes for efficient queries
create index if not exists idx_document_chunks_document_id
  on public.document_chunks (document_id);

create index if not exists idx_document_chunks_archive_member
  on public.document_chunks (archive_filename, member);

create index if not exists idx_document_chunks_tsv
  on public.document_chunks using gin (tsv_content);

create index if not exists idx_document_chunks_embedding_hnsw
  on public.document_chunks
  using hnsw (embedding vector_cosine_ops)
  where embedding is not null;

-- Composite index for common query patterns
create index if not exists idx_document_chunks_archive_chunk
  on public.document_chunks (archive_filename, chunk_index);

-- Enable RLS
alter table public.document_chunks enable row level security;

-- RLS policies
create policy "Service role manages document chunks"
on public.document_chunks
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

-- Function to search chunks with hybrid search (FTS + Vector) using RRF
create or replace function search_document_chunks_hybrid(
  search_query text,
  query_embedding vector(1536),
  result_limit integer default 10,
  result_offset integer default 0,
  rrf_k integer default 60
)
returns table (
  id bigint,
  document_id bigint,
  chunk_index integer,
  content text,
  archive_filename text,
  member text,
  document_title text,
  document_date text,
  section_title text,
  section_number text,
  fts_rank real,
  vector_distance real,
  rrf_score real
)
language plpgsql
as $$
declare
  fts_query text;
  tokens text[];
begin
  -- Extract tokens from search query for FTS
  tokens := string_to_array(lower(trim(search_query)), ' ');
  fts_query := array_to_string(
    array(
      select token || ':*'
      from unnest(tokens) as token
      where length(token) > 0
    ),
    ' & '
  );

  if fts_query is null or fts_query = '' then
    fts_query := '';
  end if;

  -- Perform hybrid search with RRF on chunks
  return query
  with
  -- Full-text search results
  fts_results as (
    select
      c.id,
      c.document_id,
      c.chunk_index,
      c.content,
      c.archive_filename,
      c.member,
      c.document_title,
      c.document_date,
      c.section_title,
      c.section_number,
      ts_rank(c.tsv_content, to_tsquery('norwegian', fts_query)) as rank
    from public.document_chunks c
    where fts_query != '' and c.tsv_content @@ to_tsquery('norwegian', fts_query)
    order by rank desc
    limit result_limit * 2
  ),
  -- Vector search results
  vector_results as (
    select
      c.id,
      c.document_id,
      c.chunk_index,
      c.content,
      c.archive_filename,
      c.member,
      c.document_title,
      c.document_date,
      c.section_title,
      c.section_number,
      1 - (c.embedding <=> query_embedding) as similarity
    from public.document_chunks c
    where c.embedding is not null
    order by c.embedding <=> query_embedding
    limit result_limit * 2
  ),
  -- Assign ranks
  fts_ranked as (
    select
      *,
      row_number() over (order by rank desc nulls last) as fts_rank_pos
    from fts_results
  ),
  vector_ranked as (
    select
      *,
      row_number() over (order by similarity desc nulls last) as vector_rank_pos
    from vector_results
  ),
  -- Combine and calculate RRF scores
  combined_results as (
    select
      coalesce(fts.id, vec.id) as id,
      coalesce(fts.document_id, vec.document_id) as document_id,
      coalesce(fts.chunk_index, vec.chunk_index) as chunk_index,
      coalesce(fts.content, vec.content) as content,
      coalesce(fts.archive_filename, vec.archive_filename) as archive_filename,
      coalesce(fts.member, vec.member) as member,
      coalesce(fts.document_title, vec.document_title) as document_title,
      coalesce(fts.document_date, vec.document_date) as document_date,
      coalesce(fts.section_title, vec.section_title) as section_title,
      coalesce(fts.section_number, vec.section_number) as section_number,
      fts.rank as fts_rank,
      vec.similarity as vector_distance,
      coalesce(1.0 / (rrf_k + fts.fts_rank_pos), 0.0) +
      coalesce(1.0 / (rrf_k + vec.vector_rank_pos), 0.0) as rrf_score
    from fts_ranked fts
    full outer join vector_ranked vec on fts.id = vec.id
  )
  select
    cr.id,
    cr.document_id,
    cr.chunk_index,
    cr.content,
    cr.archive_filename,
    cr.member,
    cr.document_title,
    cr.document_date,
    cr.section_title,
    cr.section_number,
    cr.fts_rank,
    cr.vector_distance,
    cr.rrf_score
  from combined_results cr
  order by cr.rrf_score desc, cr.fts_rank desc nulls last, cr.vector_distance desc nulls last
  limit result_limit
  offset result_offset;
end;
$$;

-- Grant execute permission
grant execute on function search_document_chunks_hybrid to service_role;

-- Comment
comment on function search_document_chunks_hybrid is 
'Hybrid search on document chunks combining FTS and vector search using RRF. 
Returns chunk-level results with preserved metadata.';

