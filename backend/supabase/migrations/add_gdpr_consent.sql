-- GDPR Consent table
-- Stores user consent records according to GDPR requirements

create table if not exists public.gdpr_consents (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  data_processing boolean not null default false,
  data_storage boolean not null default false,
  data_sharing boolean not null default false,
  marketing boolean not null default false,
  consent_date timestamptz not null default timezone('utc', now()),
  ip_address text,
  user_agent text,
  version text not null default '1.0', -- Track consent form version
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  
  -- Ensure one consent record per user (latest consent)
  constraint unique_user_consent unique (user_id)
);

create index if not exists idx_gdpr_consents_user_id on public.gdpr_consents (user_id);
create index if not exists idx_gdpr_consents_consent_date on public.gdpr_consents (consent_date);

-- Trigger to update updated_at timestamp
create trigger gdpr_consents_set_timestamp
before update on public.gdpr_consents
for each row
execute procedure public.set_current_timestamp();

-- Enable Row Level Security
alter table public.gdpr_consents enable row level security;

-- Policy: Users can read their own consent records
create policy "Users can read their own consent"
on public.gdpr_consents
for select
using (auth.uid() = user_id);

-- Policy: Service role can manage all consent records
create policy "Service role can manage consents"
on public.gdpr_consents
for all
using (auth.role() = 'service_role')
with check (auth.role() = 'service_role');

-- Policy: Users can insert/update their own consent (for initial consent and updates)
create policy "Users can manage their own consent"
on public.gdpr_consents
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

